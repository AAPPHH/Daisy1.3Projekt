# Spiel gegen Computer (einfache KI, besser als Zufall)

"""Definition einfache KI: Der Bot 2 soll auf den Player (Mensch) reagieren,
ohne durch einen Minimax-Algorithmus Gewinnoptionen zu berechnen."""

import random

def evaluate_board(board):
    # Eine einfache Bewertungsfunktion, die die Anzahl aufeinanderfolgender Steine zählt
    score = 0
    for row in board:
        for i in range(len(row) - 4):
            if row[i:i + 5] == ['X', 'X', 'X', 'X', 'X']:
                score += 100
            elif row[i:i + 5] == ['O', 'O', 'O', 'O', 'O']:
                score -= 100

    for col in zip(*board):
        for i in range(len(col) - 4):
            if list(col[i:i + 5]) == ['X', 'X', 'X', 'X', 'X']:
                score += 100
            elif list(col[i:i + 5]) == ['O', 'O', 'O', 'O', 'O']:
                score -= 100

    for i in range(len(board) - 4):
        for j in range(len(board[i]) - 4):
            if [board[i + k][j + k] for k in range(5)] == ['X', 'X', 'X', 'X', 'X']:
                score += 100
            elif [board[i + k][j + k] for k in range(5)] == ['O', 'O', 'O', 'O', 'O']:
                score -= 100

    for i in range(len(board) - 4):
        for j in range(len(board[i]) - 4):
            if [board[i + k][j - k] for k in range(5)] == ['X', 'X', 'X', 'X', 'X']:
                score += 100
            elif [board[i + k][j - k] for k in range(5)] == ['O', 'O', 'O', 'O', 'O']:
                score -= 100

    return score

def make_move(board, player, row, col):
    if board[row][col] == ' ':
        board[row][col] = player

def get_empty_cells(board):
    # Gib eine Liste der leeren Zellen auf dem Spielfeld zurück
    return [(i, j) for i in range(len(board)) for j in range(len(board[i])) if board[i][j] == ' ']

def ai_move(board, player):
    empty_cells = get_empty_cells(board)
    best_score = float('-inf')
    best_move = random.choice(empty_cells)

    for move in empty_cells:
        row, col = move
        board[row][col] = player
        score = evaluate_board(board)
        board[row][col] = ' '

        if score > best_score:
            best_score = score
            best_move = move

    return best_move

def print_board(board):
    for row in board:
        print(' '.join(row))

def main():
    board_size = 15
    board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
    current_player = 'X'

    while True:
        print_board(board)
        if current_player == 'X':
            row, col = map(int, input("Spieler X, geben Sie Ihren Zug ein (Format: Zeile Spalte): ").split())
            make_move(board, current_player, row, col)
        else:
            row, col = ai_move(board, current_player)
            make_move(board, current_player, row, col)

        if evaluate_board(board) == 100:
            print_board(board)
            print("Spieler X gewinnt!")
            break
        elif evaluate_board(board) == -100:
            print_board(board)
            print("Spieler O gewinnt!")
            break
        elif len(get_empty_cells(board)) == 0:
            print_board(board)
            print("Unentschieden!")
            break

        current_player = 'O' if current_player == 'X' else 'X'

if __name__ == "__main__":
    main()




#%%





import numpy
import random

class Bot_2:
    def __init__(m, n, board, player):
        self.m = m
        self.n = n
        self.board = board
        self.player = player
        
    def make_move(self, m, n, board):
        if np.all(board == 0) == True:
            random_row = random.randint(0, m-1)
            random_column = random.randint(0, n-1)
            return board.board[random_row][random_column]
        elif np.all(board == 1) == True:
            location_of_the_one = np.where(board == 1)

            """Wenn die location am linken Rand der Matrix ist, dann ist new_row = location_of_the_row + 1
            Wenn die location am rechten Rand der Matrix ist, dann ist new_row = location_of_the_row - 1
            Wenn die location am unteren Rand der Matrix ist, dann ist new_column = location_of_the_column + 1
            Wenn die location am obere Rand der Matrix ist, dann ist new_column = location_of_the_column - 1"""

            while board.board[random_row][random_column] == 1:
                random_row = random.randint(0, m-1)
                random_column = random.randint(0, n-1)
            return board.board[random_row][random_column]
        elif np.all(board == 2) == True:
            random_row = random.randint(0, m-1)
            random_column = random.randint(0, n-1)
            while board.board[random_row][random_column] == 2:
                random_row = random.randint(0, m-1)
                random_column = random.randint(0, n-1)
            return board.board[random_row][random_column]
        else:
            return self.board





#%%





class SimpleBot:
    def __init__(self, piece):
        self.piece = piece

    def make_move(self, board):
        if board.is_valid_move(board.m // 2, board.n // 2):
            return board.m // 2, board.n // 2

        for i in range(board.m):
            for j in range(board.n):
                if board.is_valid_move(i, j):
                    return i, j

        

        






